/* automatically generated by rust-bindgen */

pub const OPJ_TRUE: u32 = 1;
pub const OPJ_FALSE: u32 = 0;
pub const OPJ_HAVE_STDINT_H: u32 = 1;
pub const OPJ_VERSION_MAJOR: u32 = 2;
pub const OPJ_VERSION_MINOR: u32 = 3;
pub const OPJ_VERSION_BUILD: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STDIO_H: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const _BITS_LIBIO_H: u32 = 1;
pub const _BITS_G_CONFIG_H: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const OPJ_PATH_LEN: u32 = 4096;
pub const OPJ_J2K_MAXRLVLS: u32 = 33;
pub const OPJ_J2K_MAXBANDS: u32 = 97;
pub const OPJ_J2K_DEFAULT_NB_SEGS: u32 = 10;
pub const OPJ_J2K_STREAM_CHUNK_SIZE: u32 = 1048576;
pub const OPJ_J2K_DEFAULT_HEADER_SIZE: u32 = 1000;
pub const OPJ_J2K_MCC_DEFAULT_NB_RECORDS: u32 = 10;
pub const OPJ_J2K_MCT_DEFAULT_NB_RECORDS: u32 = 10;
pub const JPWL_MAX_NO_TILESPECS: u32 = 16;
pub const JPWL_MAX_NO_PACKSPECS: u32 = 16;
pub const JPWL_MAX_NO_MARKERS: u32 = 512;
pub const JPWL_PRIVATEINDEX_NAME: &'static [u8; 27usize] = b"jpwl_index_privatefilename\0";
pub const JPWL_EXPECTED_COMPONENTS: u32 = 3;
pub const JPWL_MAXIMUM_TILES: u32 = 8192;
pub const JPWL_MAXIMUM_HAMMING: u32 = 2;
pub const JPWL_MAXIMUM_EPB_ROOM: u32 = 65450;
pub const OPJ_IMG_INFO: u32 = 1;
pub const OPJ_J2K_MH_INFO: u32 = 2;
pub const OPJ_J2K_TH_INFO: u32 = 4;
pub const OPJ_J2K_TCH_INFO: u32 = 8;
pub const OPJ_J2K_MH_IND: u32 = 16;
pub const OPJ_J2K_TH_IND: u32 = 32;
pub const OPJ_JP2_INFO: u32 = 128;
pub const OPJ_JP2_IND: u32 = 256;
pub const OPJ_PROFILE_NONE: u32 = 0;
pub const OPJ_PROFILE_0: u32 = 1;
pub const OPJ_PROFILE_1: u32 = 2;
pub const OPJ_PROFILE_PART2: u32 = 32768;
pub const OPJ_PROFILE_CINEMA_2K: u32 = 3;
pub const OPJ_PROFILE_CINEMA_4K: u32 = 4;
pub const OPJ_PROFILE_CINEMA_S2K: u32 = 5;
pub const OPJ_PROFILE_CINEMA_S4K: u32 = 6;
pub const OPJ_PROFILE_CINEMA_LTS: u32 = 7;
pub const OPJ_PROFILE_BC_SINGLE: u32 = 256;
pub const OPJ_PROFILE_BC_MULTI: u32 = 512;
pub const OPJ_PROFILE_BC_MULTI_R: u32 = 768;
pub const OPJ_PROFILE_IMF_2K: u32 = 1024;
pub const OPJ_PROFILE_IMF_4K: u32 = 1025;
pub const OPJ_PROFILE_IMF_8K: u32 = 1026;
pub const OPJ_PROFILE_IMF_2K_R: u32 = 1027;
pub const OPJ_PROFILE_IMF_4K_R: u32 = 2048;
pub const OPJ_PROFILE_IMF_8K_R: u32 = 2049;
pub const OPJ_EXTENSION_NONE: u32 = 0;
pub const OPJ_EXTENSION_MCT: u32 = 256;
pub const OPJ_CINEMA_24_CS: u32 = 1302083;
pub const OPJ_CINEMA_48_CS: u32 = 651041;
pub const OPJ_CINEMA_24_COMP: u32 = 1041666;
pub const OPJ_CINEMA_48_COMP: u32 = 520833;
pub const OPJ_DPARAMETERS_IGNORE_PCLR_CMAP_CDEF_FLAG: u32 = 1;
pub const OPJ_DPARAMETERS_DUMP_FLAG: u32 = 2;
pub const OPJ_STREAM_READ: u32 = 1;
pub const OPJ_STREAM_WRITE: u32 = 0;
pub type OPJ_BOOL = ::std::os::raw::c_int;
pub type OPJ_CHAR = ::std::os::raw::c_char;
pub type OPJ_FLOAT32 = f32;
pub type OPJ_FLOAT64 = f64;
pub type OPJ_BYTE = ::std::os::raw::c_uchar;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__fsid_t), "::", stringify!(__val))
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type OPJ_INT8 = i8;
pub type OPJ_UINT8 = u8;
pub type OPJ_INT16 = i16;
pub type OPJ_UINT16 = u16;
pub type OPJ_INT32 = i32;
pub type OPJ_UINT32 = u32;
pub type OPJ_INT64 = i64;
pub type OPJ_UINT64 = u64;
pub type OPJ_OFF_T = i64;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
impl ::std::fmt::Debug for __mbstate_t__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "__mbstate_t__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__mbstate_t), "::", stringify!(__count))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(__mbstate_t), "::", stringify!(__value))
    );
}
impl ::std::fmt::Debug for __mbstate_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "__mbstate_t {{ __count: {:?}, __value: {:?} }}", self.__count, self.__value)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_G_fpos_t), "::", stringify!(__pos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_G_fpos_t), "::", stringify!(__state))
    );
}
impl ::std::fmt::Debug for _G_fpos_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_G_fpos_t {{ __pos: {:?}, __state: {:?} }}", self.__pos, self.__state)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_G_fpos64_t), "::", stringify!(__pos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_G_fpos64_t), "::", stringify!(__state))
    );
}
impl ::std::fmt::Debug for _G_fpos64_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_G_fpos64_t {{ __pos: {:?}, __state: {:?} }}", self.__pos, self.__state)
    }
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_IO_marker), "::", stringify!(_next))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_IO_marker), "::", stringify!(_sbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_IO_marker), "::", stringify!(_pos))
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_read_ptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_read_end))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_read_base))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_write_base))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_write_ptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_write_end))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_buf_base))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_buf_end))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_save_base))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_backup_base))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_save_end))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_markers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_chain))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_fileno))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_flags2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_old_offset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_cur_column))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_vtable_offset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_shortbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_lock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_offset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        152usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(__pad1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        160usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(__pad2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        168usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(__pad3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        176usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(__pad4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(__pad5))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_mode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_unused2))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type __io_close_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int, arg3: __ssize_t)
        -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void, arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __s: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
pub type OPJ_SIZE_T = usize;
#[repr(u32)]
#[doc = " DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead"]
#[doc = " Rsiz Capabilities"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RSIZ_CAPABILITIES {
    OPJ_STD_RSIZ = 0,
    #[doc = " Standard JPEG2000 profile"]
    OPJ_CINEMA2K = 3,
    #[doc = " Profile name for a 2K image"]
    OPJ_CINEMA4K = 4,
    #[doc = " Profile name for a 4K image"]
    OPJ_MCT = 33024,
}
pub use self::RSIZ_CAPABILITIES as OPJ_RSIZ_CAPABILITIES;
#[repr(u32)]
#[doc = " DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead"]
#[doc = " Digital cinema operation mode"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CINEMA_MODE {
    OPJ_OFF = 0,
    #[doc = " Not Digital Cinema"]
    OPJ_CINEMA2K_24 = 1,
    #[doc = " 2K Digital Cinema at 24 fps"]
    OPJ_CINEMA2K_48 = 2,
    #[doc = " 2K Digital Cinema at 48 fps"]
    OPJ_CINEMA4K_24 = 3,
}
pub use self::CINEMA_MODE as OPJ_CINEMA_MODE;
#[repr(i32)]
#[doc = " Progression order"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum PROG_ORDER {
    #[doc = "< place-holder"]
    OPJ_PROG_UNKNOWN = -1,
    #[doc = "< layer-resolution-component-precinct order"]
    OPJ_LRCP = 0,
    #[doc = "< resolution-layer-component-precinct order"]
    OPJ_RLCP = 1,
    #[doc = "< resolution-precinct-component-layer order"]
    OPJ_RPCL = 2,
    #[doc = "< precinct-component-resolution-layer order"]
    OPJ_PCRL = 3,
    #[doc = "< component-precinct-resolution-layer order"]
    OPJ_CPRL = 4,
}
pub use self::PROG_ORDER as OPJ_PROG_ORDER;
#[repr(i32)]
#[doc = " Supported image color spaces"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum COLOR_SPACE {
    #[doc = "< not supported by the library"]
    OPJ_CLRSPC_UNKNOWN = -1,
    #[doc = "< not specified in the codestream"]
    OPJ_CLRSPC_UNSPECIFIED = 0,
    #[doc = "< sRGB"]
    OPJ_CLRSPC_SRGB = 1,
    #[doc = "< grayscale"]
    OPJ_CLRSPC_GRAY = 2,
    #[doc = "< YUV"]
    OPJ_CLRSPC_SYCC = 3,
    #[doc = "< e-YCC"]
    OPJ_CLRSPC_EYCC = 4,
    #[doc = "< CMYK"]
    OPJ_CLRSPC_CMYK = 5,
}
pub use self::COLOR_SPACE as OPJ_COLOR_SPACE;
#[repr(i32)]
#[doc = " Supported codec"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CODEC_FORMAT {
    #[doc = "< place-holder"]
    OPJ_CODEC_UNKNOWN = -1,
    #[doc = "< JPEG-2000 codestream : read/write"]
    OPJ_CODEC_J2K = 0,
    #[doc = "< JPT-stream (JPEG 2000, JPIP) : read only"]
    OPJ_CODEC_JPT = 1,
    #[doc = "< JP2 file format : read/write"]
    OPJ_CODEC_JP2 = 2,
    #[doc = "< JPP-stream (JPEG 2000, JPIP) : to be coded"]
    OPJ_CODEC_JPP = 3,
    #[doc = "< JPX file format (JPEG 2000 Part-2) : to be coded"]
    OPJ_CODEC_JPX = 4,
}
pub use self::CODEC_FORMAT as OPJ_CODEC_FORMAT;
#[doc = " Callback function prototype for events"]
#[doc = " @param msg               Event message"]
#[doc = " @param client_data       Client object where will be return the event message"]
pub type opj_msg_callback = ::std::option::Option<
    unsafe extern "C" fn(
        msg: *const ::std::os::raw::c_char,
        client_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Progression order changes"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_poc {
    #[doc = " Resolution num start, Component num start, given by POC"]
    pub resno0: OPJ_UINT32,
    #[doc = " Resolution num start, Component num start, given by POC"]
    pub compno0: OPJ_UINT32,
    #[doc = " Layer num end,Resolution num end, Component num end, given by POC"]
    pub layno1: OPJ_UINT32,
    #[doc = " Layer num end,Resolution num end, Component num end, given by POC"]
    pub resno1: OPJ_UINT32,
    #[doc = " Layer num end,Resolution num end, Component num end, given by POC"]
    pub compno1: OPJ_UINT32,
    #[doc = " Layer num start,Precinct num start, Precinct num end"]
    pub layno0: OPJ_UINT32,
    #[doc = " Layer num start,Precinct num start, Precinct num end"]
    pub precno0: OPJ_UINT32,
    #[doc = " Layer num start,Precinct num start, Precinct num end"]
    pub precno1: OPJ_UINT32,
    #[doc = " Progression order enum"]
    pub prg1: OPJ_PROG_ORDER,
    #[doc = " Progression order enum"]
    pub prg: OPJ_PROG_ORDER,
    #[doc = " Progression order string"]
    pub progorder: [OPJ_CHAR; 5usize],
    #[doc = " Tile number (starting at 1)"]
    pub tile: OPJ_UINT32,
    #[doc = " Start and end values for Tile width and height"]
    pub tx0: OPJ_INT32,
    #[doc = " Start and end values for Tile width and height"]
    pub tx1: OPJ_INT32,
    #[doc = " Start and end values for Tile width and height"]
    pub ty0: OPJ_INT32,
    #[doc = " Start and end values for Tile width and height"]
    pub ty1: OPJ_INT32,
    #[doc = " Start value, initialised in pi_initialise_encode"]
    pub layS: OPJ_UINT32,
    #[doc = " Start value, initialised in pi_initialise_encode"]
    pub resS: OPJ_UINT32,
    #[doc = " Start value, initialised in pi_initialise_encode"]
    pub compS: OPJ_UINT32,
    #[doc = " Start value, initialised in pi_initialise_encode"]
    pub prcS: OPJ_UINT32,
    #[doc = " End value, initialised in pi_initialise_encode"]
    pub layE: OPJ_UINT32,
    #[doc = " End value, initialised in pi_initialise_encode"]
    pub resE: OPJ_UINT32,
    #[doc = " End value, initialised in pi_initialise_encode"]
    pub compE: OPJ_UINT32,
    #[doc = " End value, initialised in pi_initialise_encode"]
    pub prcE: OPJ_UINT32,
    #[doc = " Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub txS: OPJ_UINT32,
    #[doc = " Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub txE: OPJ_UINT32,
    #[doc = " Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub tyS: OPJ_UINT32,
    #[doc = " Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub tyE: OPJ_UINT32,
    #[doc = " Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub dx: OPJ_UINT32,
    #[doc = " Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub dy: OPJ_UINT32,
    #[doc = " Temporary values for Tile parts, initialised in pi_create_encode"]
    pub lay_t: OPJ_UINT32,
    #[doc = " Temporary values for Tile parts, initialised in pi_create_encode"]
    pub res_t: OPJ_UINT32,
    #[doc = " Temporary values for Tile parts, initialised in pi_create_encode"]
    pub comp_t: OPJ_UINT32,
    #[doc = " Temporary values for Tile parts, initialised in pi_create_encode"]
    pub prc_t: OPJ_UINT32,
    #[doc = " Temporary values for Tile parts, initialised in pi_create_encode"]
    pub tx0_t: OPJ_UINT32,
    #[doc = " Temporary values for Tile parts, initialised in pi_create_encode"]
    pub ty0_t: OPJ_UINT32,
}
#[test]
fn bindgen_test_layout_opj_poc() {
    assert_eq!(
        ::std::mem::size_of::<opj_poc>(),
        148usize,
        concat!("Size of: ", stringify!(opj_poc))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_poc>(),
        4usize,
        concat!("Alignment of ", stringify!(opj_poc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).resno0 as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(resno0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).compno0 as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(compno0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).layno1 as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(layno1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).resno1 as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(resno1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).compno1 as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(compno1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).layno0 as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(layno0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).precno0 as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(precno0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).precno1 as *const _ as usize },
        28usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(precno1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).prg1 as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(prg1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).prg as *const _ as usize },
        36usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(prg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).progorder as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(progorder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).tile as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(tile))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).tx0 as *const _ as usize },
        52usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(tx0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).tx1 as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(tx1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).ty0 as *const _ as usize },
        60usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(ty0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).ty1 as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(ty1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).layS as *const _ as usize },
        68usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(layS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).resS as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(resS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).compS as *const _ as usize },
        76usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(compS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).prcS as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(prcS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).layE as *const _ as usize },
        84usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(layE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).resE as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(resE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).compE as *const _ as usize },
        92usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(compE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).prcE as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(prcE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).txS as *const _ as usize },
        100usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(txS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).txE as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(txE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).tyS as *const _ as usize },
        108usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(tyS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).tyE as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(tyE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).dx as *const _ as usize },
        116usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(dx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).dy as *const _ as usize },
        120usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(dy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).lay_t as *const _ as usize },
        124usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(lay_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).res_t as *const _ as usize },
        128usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(res_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).comp_t as *const _ as usize },
        132usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(comp_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).prc_t as *const _ as usize },
        136usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(prc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).tx0_t as *const _ as usize },
        140usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(tx0_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).ty0_t as *const _ as usize },
        144usize,
        concat!("Offset of field: ", stringify!(opj_poc), "::", stringify!(ty0_t))
    );
}
pub type opj_poc_t = opj_poc;
#[doc = " Compression parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct opj_cparameters {
    #[doc = " size of tile: tile_size_on = false (not in argument) or = true (in argument)"]
    pub tile_size_on: OPJ_BOOL,
    #[doc = " XTOsiz"]
    pub cp_tx0: ::std::os::raw::c_int,
    #[doc = " YTOsiz"]
    pub cp_ty0: ::std::os::raw::c_int,
    #[doc = " XTsiz"]
    pub cp_tdx: ::std::os::raw::c_int,
    #[doc = " YTsiz"]
    pub cp_tdy: ::std::os::raw::c_int,
    #[doc = " allocation by rate/distortion"]
    pub cp_disto_alloc: ::std::os::raw::c_int,
    #[doc = " allocation by fixed layer"]
    pub cp_fixed_alloc: ::std::os::raw::c_int,
    #[doc = " add fixed_quality"]
    pub cp_fixed_quality: ::std::os::raw::c_int,
    #[doc = " fixed layer"]
    pub cp_matrice: *mut ::std::os::raw::c_int,
    #[doc = " comment for coding"]
    pub cp_comment: *mut ::std::os::raw::c_char,
    #[doc = " csty : coding style"]
    pub csty: ::std::os::raw::c_int,
    #[doc = " progression order (default OPJ_LRCP)"]
    pub prog_order: OPJ_PROG_ORDER,
    #[doc = " progression order changes"]
    pub POC: [opj_poc_t; 32usize],
    #[doc = " number of progression order changes (POC), default to 0"]
    pub numpocs: OPJ_UINT32,
    #[doc = " number of layers"]
    pub tcp_numlayers: ::std::os::raw::c_int,
    #[doc = " rates of layers - might be subsequently limited by the max_cs_size field."]
    #[doc = " Should be decreasing. 1 can be"]
    #[doc = " used as last value to indicate the last layer is lossless."]
    pub tcp_rates: [f32; 100usize],
    #[doc = " different psnr for successive layers. Should be increasing. 0 can be"]
    #[doc = " used as last value to indicate the last layer is lossless."]
    pub tcp_distoratio: [f32; 100usize],
    #[doc = " number of resolutions"]
    pub numresolution: ::std::os::raw::c_int,
    #[doc = " initial code block width, default to 64"]
    pub cblockw_init: ::std::os::raw::c_int,
    #[doc = " initial code block height, default to 64"]
    pub cblockh_init: ::std::os::raw::c_int,
    #[doc = " mode switch (cblk_style)"]
    pub mode: ::std::os::raw::c_int,
    #[doc = " 1 : use the irreversible DWT 9-7, 0 : use lossless compression (default)"]
    pub irreversible: ::std::os::raw::c_int,
    #[doc = " region of interest: affected component in [0..3], -1 means no ROI"]
    pub roi_compno: ::std::os::raw::c_int,
    #[doc = " region of interest: upshift value"]
    pub roi_shift: ::std::os::raw::c_int,
    pub res_spec: ::std::os::raw::c_int,
    #[doc = " initial precinct width"]
    pub prcw_init: [::std::os::raw::c_int; 33usize],
    #[doc = " initial precinct height"]
    pub prch_init: [::std::os::raw::c_int; 33usize],
    #[doc = " input file name"]
    pub infile: [::std::os::raw::c_char; 4096usize],
    #[doc = " output file name"]
    pub outfile: [::std::os::raw::c_char; 4096usize],
    #[doc = " DEPRECATED. Index generation is now handeld with the opj_encode_with_info() function. Set to NULL"]
    pub index_on: ::std::os::raw::c_int,
    #[doc = " DEPRECATED. Index generation is now handeld with the opj_encode_with_info() function. Set to NULL"]
    pub index: [::std::os::raw::c_char; 4096usize],
    #[doc = " subimage encoding: origin image offset in x direction"]
    pub image_offset_x0: ::std::os::raw::c_int,
    #[doc = " subimage encoding: origin image offset in y direction"]
    pub image_offset_y0: ::std::os::raw::c_int,
    #[doc = " subsampling value for dx"]
    pub subsampling_dx: ::std::os::raw::c_int,
    #[doc = " subsampling value for dy"]
    pub subsampling_dy: ::std::os::raw::c_int,
    #[doc = " input file format 0: PGX, 1: PxM, 2: BMP 3:TIF"]
    pub decod_format: ::std::os::raw::c_int,
    #[doc = " output file format 0: J2K, 1: JP2, 2: JPT"]
    pub cod_format: ::std::os::raw::c_int,
    #[doc = " enables writing of EPC in MH, thus activating JPWL"]
    pub jpwl_epc_on: OPJ_BOOL,
    #[doc = " error protection method for MH (0,1,16,32,37-128)"]
    pub jpwl_hprot_MH: ::std::os::raw::c_int,
    #[doc = " tile number of header protection specification (>=0)"]
    pub jpwl_hprot_TPH_tileno: [::std::os::raw::c_int; 16usize],
    #[doc = " error protection methods for TPHs (0,1,16,32,37-128)"]
    pub jpwl_hprot_TPH: [::std::os::raw::c_int; 16usize],
    #[doc = " tile number of packet protection specification (>=0)"]
    pub jpwl_pprot_tileno: [::std::os::raw::c_int; 16usize],
    #[doc = " packet number of packet protection specification (>=0)"]
    pub jpwl_pprot_packno: [::std::os::raw::c_int; 16usize],
    #[doc = " error protection methods for packets (0,1,16,32,37-128)"]
    pub jpwl_pprot: [::std::os::raw::c_int; 16usize],
    #[doc = " enables writing of ESD, (0=no/1/2 bytes)"]
    pub jpwl_sens_size: ::std::os::raw::c_int,
    #[doc = " sensitivity addressing size (0=auto/2/4 bytes)"]
    pub jpwl_sens_addr: ::std::os::raw::c_int,
    #[doc = " sensitivity range (0-3)"]
    pub jpwl_sens_range: ::std::os::raw::c_int,
    #[doc = " sensitivity method for MH (-1=no,0-7)"]
    pub jpwl_sens_MH: ::std::os::raw::c_int,
    #[doc = " tile number of sensitivity specification (>=0)"]
    pub jpwl_sens_TPH_tileno: [::std::os::raw::c_int; 16usize],
    #[doc = " sensitivity methods for TPHs (-1=no,0-7)"]
    pub jpwl_sens_TPH: [::std::os::raw::c_int; 16usize],
    #[doc = " DEPRECATED: use RSIZ, OPJ_PROFILE_* and MAX_COMP_SIZE instead"]
    #[doc = " Digital Cinema compliance 0-not compliant, 1-compliant"]
    pub cp_cinema: OPJ_CINEMA_MODE,
    #[doc = " Maximum size (in bytes) for each component."]
    #[doc = " If == 0, component size limitation is not considered"]
    pub max_comp_size: ::std::os::raw::c_int,
    #[doc = " DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead"]
    #[doc = " Profile name"]
    pub cp_rsiz: OPJ_RSIZ_CAPABILITIES,
    #[doc = " Tile part generation"]
    pub tp_on: ::std::os::raw::c_char,
    #[doc = " Flag for Tile part generation"]
    pub tp_flag: ::std::os::raw::c_char,
    #[doc = " MCT (multiple component transform)"]
    pub tcp_mct: ::std::os::raw::c_char,
    #[doc = " Enable JPIP indexing"]
    pub jpip_on: OPJ_BOOL,
    #[doc = " Naive implementation of MCT restricted to a single reversible array based"]
    #[doc = "encoding without offset concerning all the components."]
    pub mct_data: *mut ::std::os::raw::c_void,
    #[doc = " Maximum size (in bytes) for the whole codestream."]
    #[doc = " If == 0, codestream size limitation is not considered"]
    #[doc = " If it does not comply with tcp_rates, max_cs_size prevails"]
    #[doc = " and a warning is issued."]
    pub max_cs_size: ::std::os::raw::c_int,
    #[doc = " RSIZ value"]
    #[doc = "To be used to combine OPJ_PROFILE_*, OPJ_EXTENSION_* and (sub)levels values."]
    pub rsiz: OPJ_UINT16,
}
#[test]
fn bindgen_test_layout_opj_cparameters() {
    assert_eq!(
        ::std::mem::size_of::<opj_cparameters>(),
        18720usize,
        concat!("Size of: ", stringify!(opj_cparameters))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_cparameters>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_cparameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).tile_size_on as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(tile_size_on))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cp_tx0 as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(cp_tx0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cp_ty0 as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(cp_ty0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cp_tdx as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(cp_tdx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cp_tdy as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(cp_tdy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cp_disto_alloc as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(cp_disto_alloc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cp_fixed_alloc as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(cp_fixed_alloc))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_cparameters>())).cp_fixed_quality as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(cp_fixed_quality)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cp_matrice as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(cp_matrice))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cp_comment as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(cp_comment))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).csty as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(csty))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).prog_order as *const _ as usize },
        52usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(prog_order))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).POC as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(POC))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).numpocs as *const _ as usize },
        4792usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(numpocs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).tcp_numlayers as *const _ as usize },
        4796usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(tcp_numlayers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).tcp_rates as *const _ as usize },
        4800usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(tcp_rates))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).tcp_distoratio as *const _ as usize },
        5200usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(tcp_distoratio))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).numresolution as *const _ as usize },
        5600usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(numresolution))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cblockw_init as *const _ as usize },
        5604usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(cblockw_init))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cblockh_init as *const _ as usize },
        5608usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(cblockh_init))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).mode as *const _ as usize },
        5612usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(mode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).irreversible as *const _ as usize },
        5616usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(irreversible))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).roi_compno as *const _ as usize },
        5620usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(roi_compno))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).roi_shift as *const _ as usize },
        5624usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(roi_shift))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).res_spec as *const _ as usize },
        5628usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(res_spec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).prcw_init as *const _ as usize },
        5632usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(prcw_init))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).prch_init as *const _ as usize },
        5764usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(prch_init))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).infile as *const _ as usize },
        5896usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(infile))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).outfile as *const _ as usize },
        9992usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(outfile))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).index_on as *const _ as usize },
        14088usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(index_on))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).index as *const _ as usize },
        14092usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(index))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).image_offset_x0 as *const _ as usize },
        18188usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(image_offset_x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).image_offset_y0 as *const _ as usize },
        18192usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(image_offset_y0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).subsampling_dx as *const _ as usize },
        18196usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(subsampling_dx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).subsampling_dy as *const _ as usize },
        18200usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(subsampling_dy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).decod_format as *const _ as usize },
        18204usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(decod_format))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cod_format as *const _ as usize },
        18208usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(cod_format))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).jpwl_epc_on as *const _ as usize },
        18212usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(jpwl_epc_on))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).jpwl_hprot_MH as *const _ as usize },
        18216usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(jpwl_hprot_MH))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_cparameters>())).jpwl_hprot_TPH_tileno as *const _ as usize
        },
        18220usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(jpwl_hprot_TPH_tileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).jpwl_hprot_TPH as *const _ as usize },
        18284usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(jpwl_hprot_TPH))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_cparameters>())).jpwl_pprot_tileno as *const _ as usize
        },
        18348usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(jpwl_pprot_tileno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_cparameters>())).jpwl_pprot_packno as *const _ as usize
        },
        18412usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(jpwl_pprot_packno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).jpwl_pprot as *const _ as usize },
        18476usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(jpwl_pprot))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).jpwl_sens_size as *const _ as usize },
        18540usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(jpwl_sens_size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).jpwl_sens_addr as *const _ as usize },
        18544usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(jpwl_sens_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).jpwl_sens_range as *const _ as usize },
        18548usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(jpwl_sens_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).jpwl_sens_MH as *const _ as usize },
        18552usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(jpwl_sens_MH))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_cparameters>())).jpwl_sens_TPH_tileno as *const _ as usize
        },
        18556usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(jpwl_sens_TPH_tileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).jpwl_sens_TPH as *const _ as usize },
        18620usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(jpwl_sens_TPH))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cp_cinema as *const _ as usize },
        18684usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(cp_cinema))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).max_comp_size as *const _ as usize },
        18688usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(max_comp_size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cp_rsiz as *const _ as usize },
        18692usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(cp_rsiz))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).tp_on as *const _ as usize },
        18696usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(tp_on))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).tp_flag as *const _ as usize },
        18697usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(tp_flag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).tcp_mct as *const _ as usize },
        18698usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(tcp_mct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).jpip_on as *const _ as usize },
        18700usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(jpip_on))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).mct_data as *const _ as usize },
        18704usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(mct_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).max_cs_size as *const _ as usize },
        18712usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(max_cs_size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).rsiz as *const _ as usize },
        18716usize,
        concat!("Offset of field: ", stringify!(opj_cparameters), "::", stringify!(rsiz))
    );
}
impl ::std::fmt::Debug for opj_cparameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "opj_cparameters {{ tile_size_on: {:?}, cp_tx0: {:?}, cp_ty0: {:?}, cp_tdx: {:?}, cp_tdy: {:?}, cp_disto_alloc: {:?}, cp_fixed_alloc: {:?}, cp_fixed_quality: {:?}, cp_matrice: {:?}, cp_comment: {:?}, csty: {:?}, prog_order: {:?}, POC: [{}], numpocs: {:?}, tcp_numlayers: {:?}, tcp_rates: [{}], tcp_distoratio: [{}], numresolution: {:?}, cblockw_init: {:?}, cblockh_init: {:?}, mode: {:?}, irreversible: {:?}, roi_compno: {:?}, roi_shift: {:?}, res_spec: {:?}, prcw_init: [{}], prch_init: [{}], infile: [{}], outfile: [{}], index_on: {:?}, index: [{}], image_offset_x0: {:?}, image_offset_y0: {:?}, subsampling_dx: {:?}, subsampling_dy: {:?}, decod_format: {:?}, cod_format: {:?}, jpwl_epc_on: {:?}, jpwl_hprot_MH: {:?}, jpwl_hprot_TPH_tileno: {:?}, jpwl_hprot_TPH: {:?}, jpwl_pprot_tileno: {:?}, jpwl_pprot_packno: {:?}, jpwl_pprot: {:?}, jpwl_sens_size: {:?}, jpwl_sens_addr: {:?}, jpwl_sens_range: {:?}, jpwl_sens_MH: {:?}, jpwl_sens_TPH_tileno: {:?}, jpwl_sens_TPH: {:?}, cp_cinema: {:?}, max_comp_size: {:?}, cp_rsiz: {:?}, tp_on: {:?}, tp_flag: {:?}, tcp_mct: {:?}, jpip_on: {:?}, mct_data: {:?}, max_cs_size: {:?}, rsiz: {:?} }}" , self . tile_size_on , self . cp_tx0 , self . cp_ty0 , self . cp_tdx , self . cp_tdy , self . cp_disto_alloc , self . cp_fixed_alloc , self . cp_fixed_quality , self . cp_matrice , self . cp_comment , self . csty , self . prog_order , self . POC . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . numpocs , self . tcp_numlayers , self . tcp_rates . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . tcp_distoratio . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . numresolution , self . cblockw_init , self . cblockh_init , self . mode , self . irreversible , self . roi_compno , self . roi_shift , self . res_spec , self . prcw_init . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . prch_init . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . infile . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . outfile . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . index_on , self . index . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . image_offset_x0 , self . image_offset_y0 , self . subsampling_dx , self . subsampling_dy , self . decod_format , self . cod_format , self . jpwl_epc_on , self . jpwl_hprot_MH , self . jpwl_hprot_TPH_tileno , self . jpwl_hprot_TPH , self . jpwl_pprot_tileno , self . jpwl_pprot_packno , self . jpwl_pprot , self . jpwl_sens_size , self . jpwl_sens_addr , self . jpwl_sens_range , self . jpwl_sens_MH , self . jpwl_sens_TPH_tileno , self . jpwl_sens_TPH , self . cp_cinema , self . max_comp_size , self . cp_rsiz , self . tp_on , self . tp_flag , self . tcp_mct , self . jpip_on , self . mct_data , self . max_cs_size , self . rsiz )
    }
}
pub type opj_cparameters_t = opj_cparameters;
#[doc = " Decompression parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct opj_dparameters {
    #[doc = "Set the number of highest resolution levels to be discarded."]
    #[doc = "The image resolution is effectively divided by 2 to the power of the number of discarded levels."]
    #[doc = "The reduce factor is limited by the smallest total number of decomposition levels among tiles."]
    #[doc = "if != 0, then original dimension divided by 2^(reduce);"]
    #[doc = "if == 0 or not used, image is decoded to the full resolution"]
    pub cp_reduce: OPJ_UINT32,
    #[doc = "Set the maximum number of quality layers to decode."]
    #[doc = "If there are less quality layers than the specified number, all the quality layers are decoded."]
    #[doc = "if != 0, then only the first \"layer\" layers are decoded;"]
    #[doc = "if == 0 or not used, all the quality layers are decoded"]
    pub cp_layer: OPJ_UINT32,
    #[doc = " input file name"]
    pub infile: [::std::os::raw::c_char; 4096usize],
    #[doc = " output file name"]
    pub outfile: [::std::os::raw::c_char; 4096usize],
    #[doc = " input file format 0: J2K, 1: JP2, 2: JPT"]
    pub decod_format: ::std::os::raw::c_int,
    #[doc = " output file format 0: PGX, 1: PxM, 2: BMP"]
    pub cod_format: ::std::os::raw::c_int,
    #[doc = " Decoding area left boundary"]
    pub DA_x0: OPJ_UINT32,
    #[doc = " Decoding area right boundary"]
    pub DA_x1: OPJ_UINT32,
    #[doc = " Decoding area up boundary"]
    pub DA_y0: OPJ_UINT32,
    #[doc = " Decoding area bottom boundary"]
    pub DA_y1: OPJ_UINT32,
    #[doc = " Verbose mode"]
    pub m_verbose: OPJ_BOOL,
    #[doc = " tile number of the decoded tile"]
    pub tile_index: OPJ_UINT32,
    #[doc = " Nb of tile to decode"]
    pub nb_tile_to_decode: OPJ_UINT32,
    #[doc = " activates the JPWL correction capabilities"]
    pub jpwl_correct: OPJ_BOOL,
    #[doc = " expected number of components"]
    pub jpwl_exp_comps: ::std::os::raw::c_int,
    #[doc = " maximum number of tiles"]
    pub jpwl_max_tiles: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_opj_dparameters() {
    assert_eq!(
        ::std::mem::size_of::<opj_dparameters>(),
        8252usize,
        concat!("Size of: ", stringify!(opj_dparameters))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_dparameters>(),
        4usize,
        concat!("Alignment of ", stringify!(opj_dparameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).cp_reduce as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(opj_dparameters), "::", stringify!(cp_reduce))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).cp_layer as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(opj_dparameters), "::", stringify!(cp_layer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).infile as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(opj_dparameters), "::", stringify!(infile))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).outfile as *const _ as usize },
        4104usize,
        concat!("Offset of field: ", stringify!(opj_dparameters), "::", stringify!(outfile))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).decod_format as *const _ as usize },
        8200usize,
        concat!("Offset of field: ", stringify!(opj_dparameters), "::", stringify!(decod_format))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).cod_format as *const _ as usize },
        8204usize,
        concat!("Offset of field: ", stringify!(opj_dparameters), "::", stringify!(cod_format))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).DA_x0 as *const _ as usize },
        8208usize,
        concat!("Offset of field: ", stringify!(opj_dparameters), "::", stringify!(DA_x0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).DA_x1 as *const _ as usize },
        8212usize,
        concat!("Offset of field: ", stringify!(opj_dparameters), "::", stringify!(DA_x1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).DA_y0 as *const _ as usize },
        8216usize,
        concat!("Offset of field: ", stringify!(opj_dparameters), "::", stringify!(DA_y0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).DA_y1 as *const _ as usize },
        8220usize,
        concat!("Offset of field: ", stringify!(opj_dparameters), "::", stringify!(DA_y1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).m_verbose as *const _ as usize },
        8224usize,
        concat!("Offset of field: ", stringify!(opj_dparameters), "::", stringify!(m_verbose))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).tile_index as *const _ as usize },
        8228usize,
        concat!("Offset of field: ", stringify!(opj_dparameters), "::", stringify!(tile_index))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_dparameters>())).nb_tile_to_decode as *const _ as usize
        },
        8232usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_dparameters),
            "::",
            stringify!(nb_tile_to_decode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).jpwl_correct as *const _ as usize },
        8236usize,
        concat!("Offset of field: ", stringify!(opj_dparameters), "::", stringify!(jpwl_correct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).jpwl_exp_comps as *const _ as usize },
        8240usize,
        concat!("Offset of field: ", stringify!(opj_dparameters), "::", stringify!(jpwl_exp_comps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).jpwl_max_tiles as *const _ as usize },
        8244usize,
        concat!("Offset of field: ", stringify!(opj_dparameters), "::", stringify!(jpwl_max_tiles))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).flags as *const _ as usize },
        8248usize,
        concat!("Offset of field: ", stringify!(opj_dparameters), "::", stringify!(flags))
    );
}
impl ::std::fmt::Debug for opj_dparameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "opj_dparameters {{ cp_reduce: {:?}, cp_layer: {:?}, infile: [{}], outfile: [{}], decod_format: {:?}, cod_format: {:?}, DA_x0: {:?}, DA_x1: {:?}, DA_y0: {:?}, DA_y1: {:?}, m_verbose: {:?}, tile_index: {:?}, nb_tile_to_decode: {:?}, jpwl_correct: {:?}, jpwl_exp_comps: {:?}, jpwl_max_tiles: {:?}, flags: {:?} }}" , self . cp_reduce , self . cp_layer , self . infile . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . outfile . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . decod_format , self . cod_format , self . DA_x0 , self . DA_x1 , self . DA_y0 , self . DA_y1 , self . m_verbose , self . tile_index , self . nb_tile_to_decode , self . jpwl_correct , self . jpwl_exp_comps , self . jpwl_max_tiles , self . flags )
    }
}
pub type opj_dparameters_t = opj_dparameters;
#[doc = " JPEG2000 codec V2."]
pub type opj_codec_t = *mut ::std::os::raw::c_void;
pub type opj_stream_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        p_buffer: *mut ::std::os::raw::c_void,
        p_nb_bytes: OPJ_SIZE_T,
        p_user_data: *mut ::std::os::raw::c_void,
    ) -> OPJ_SIZE_T,
>;
pub type opj_stream_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        p_buffer: *mut ::std::os::raw::c_void,
        p_nb_bytes: OPJ_SIZE_T,
        p_user_data: *mut ::std::os::raw::c_void,
    ) -> OPJ_SIZE_T,
>;
pub type opj_stream_skip_fn = ::std::option::Option<
    unsafe extern "C" fn(
        p_nb_bytes: OPJ_OFF_T,
        p_user_data: *mut ::std::os::raw::c_void,
    ) -> OPJ_OFF_T,
>;
pub type opj_stream_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        p_nb_bytes: OPJ_OFF_T,
        p_user_data: *mut ::std::os::raw::c_void,
    ) -> OPJ_BOOL,
>;
pub type opj_stream_free_user_data_fn =
    ::std::option::Option<unsafe extern "C" fn(p_user_data: *mut ::std::os::raw::c_void)>;
pub type opj_stream_t = *mut ::std::os::raw::c_void;
#[doc = " Defines a single image component"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_image_comp {
    #[doc = " XRsiz: horizontal separation of a sample of ith component with respect to the reference grid"]
    pub dx: OPJ_UINT32,
    #[doc = " YRsiz: vertical separation of a sample of ith component with respect to the reference grid"]
    pub dy: OPJ_UINT32,
    #[doc = " data width"]
    pub w: OPJ_UINT32,
    #[doc = " data height"]
    pub h: OPJ_UINT32,
    #[doc = " x component offset compared to the whole image"]
    pub x0: OPJ_UINT32,
    #[doc = " y component offset compared to the whole image"]
    pub y0: OPJ_UINT32,
    #[doc = " precision"]
    pub prec: OPJ_UINT32,
    #[doc = " image depth in bits"]
    pub bpp: OPJ_UINT32,
    #[doc = " signed (1) / unsigned (0)"]
    pub sgnd: OPJ_UINT32,
    #[doc = " number of decoded resolution"]
    pub resno_decoded: OPJ_UINT32,
    #[doc = " number of division by 2 of the out image compared to the original size of image"]
    pub factor: OPJ_UINT32,
    #[doc = " image component data"]
    pub data: *mut OPJ_INT32,
    #[doc = " alpha channel"]
    pub alpha: OPJ_UINT16,
}
#[test]
fn bindgen_test_layout_opj_image_comp() {
    assert_eq!(
        ::std::mem::size_of::<opj_image_comp>(),
        64usize,
        concat!("Size of: ", stringify!(opj_image_comp))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_image_comp>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_image_comp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).dx as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(opj_image_comp), "::", stringify!(dx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).dy as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(opj_image_comp), "::", stringify!(dy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).w as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(opj_image_comp), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).h as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(opj_image_comp), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).x0 as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(opj_image_comp), "::", stringify!(x0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).y0 as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(opj_image_comp), "::", stringify!(y0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).prec as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(opj_image_comp), "::", stringify!(prec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).bpp as *const _ as usize },
        28usize,
        concat!("Offset of field: ", stringify!(opj_image_comp), "::", stringify!(bpp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).sgnd as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(opj_image_comp), "::", stringify!(sgnd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).resno_decoded as *const _ as usize },
        36usize,
        concat!("Offset of field: ", stringify!(opj_image_comp), "::", stringify!(resno_decoded))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).factor as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(opj_image_comp), "::", stringify!(factor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).data as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(opj_image_comp), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).alpha as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(opj_image_comp), "::", stringify!(alpha))
    );
}
pub type opj_image_comp_t = opj_image_comp;
#[doc = " Defines image data and characteristics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_image {
    #[doc = " XOsiz: horizontal offset from the origin of the reference grid to the left side of the image area"]
    pub x0: OPJ_UINT32,
    #[doc = " YOsiz: vertical offset from the origin of the reference grid to the top side of the image area"]
    pub y0: OPJ_UINT32,
    #[doc = " Xsiz: width of the reference grid"]
    pub x1: OPJ_UINT32,
    #[doc = " Ysiz: height of the reference grid"]
    pub y1: OPJ_UINT32,
    #[doc = " number of components in the image"]
    pub numcomps: OPJ_UINT32,
    #[doc = " color space: sRGB, Greyscale or YUV"]
    pub color_space: OPJ_COLOR_SPACE,
    #[doc = " image components"]
    pub comps: *mut opj_image_comp_t,
    #[doc = " 'restricted' ICC profile"]
    pub icc_profile_buf: *mut OPJ_BYTE,
    #[doc = " size of ICC profile"]
    pub icc_profile_len: OPJ_UINT32,
}
#[test]
fn bindgen_test_layout_opj_image() {
    assert_eq!(
        ::std::mem::size_of::<opj_image>(),
        48usize,
        concat!("Size of: ", stringify!(opj_image))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_image>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_image))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image>())).x0 as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(opj_image), "::", stringify!(x0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image>())).y0 as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(opj_image), "::", stringify!(y0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image>())).x1 as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(opj_image), "::", stringify!(x1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image>())).y1 as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(opj_image), "::", stringify!(y1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image>())).numcomps as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(opj_image), "::", stringify!(numcomps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image>())).color_space as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(opj_image), "::", stringify!(color_space))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image>())).comps as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(opj_image), "::", stringify!(comps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image>())).icc_profile_buf as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(opj_image), "::", stringify!(icc_profile_buf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image>())).icc_profile_len as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(opj_image), "::", stringify!(icc_profile_len))
    );
}
pub type opj_image_t = opj_image;
#[doc = " Component parameters structure used by the opj_image_create function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_image_comptparm {
    #[doc = " XRsiz: horizontal separation of a sample of ith component with respect to the reference grid"]
    pub dx: OPJ_UINT32,
    #[doc = " YRsiz: vertical separation of a sample of ith component with respect to the reference grid"]
    pub dy: OPJ_UINT32,
    #[doc = " data width"]
    pub w: OPJ_UINT32,
    #[doc = " data height"]
    pub h: OPJ_UINT32,
    #[doc = " x component offset compared to the whole image"]
    pub x0: OPJ_UINT32,
    #[doc = " y component offset compared to the whole image"]
    pub y0: OPJ_UINT32,
    #[doc = " precision"]
    pub prec: OPJ_UINT32,
    #[doc = " image depth in bits"]
    pub bpp: OPJ_UINT32,
    #[doc = " signed (1) / unsigned (0)"]
    pub sgnd: OPJ_UINT32,
}
#[test]
fn bindgen_test_layout_opj_image_comptparm() {
    assert_eq!(
        ::std::mem::size_of::<opj_image_comptparm>(),
        36usize,
        concat!("Size of: ", stringify!(opj_image_comptparm))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_image_comptparm>(),
        4usize,
        concat!("Alignment of ", stringify!(opj_image_comptparm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comptparm>())).dx as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(opj_image_comptparm), "::", stringify!(dx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comptparm>())).dy as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(opj_image_comptparm), "::", stringify!(dy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comptparm>())).w as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(opj_image_comptparm), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comptparm>())).h as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(opj_image_comptparm), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comptparm>())).x0 as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(opj_image_comptparm), "::", stringify!(x0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comptparm>())).y0 as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(opj_image_comptparm), "::", stringify!(y0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comptparm>())).prec as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(opj_image_comptparm), "::", stringify!(prec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comptparm>())).bpp as *const _ as usize },
        28usize,
        concat!("Offset of field: ", stringify!(opj_image_comptparm), "::", stringify!(bpp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comptparm>())).sgnd as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(opj_image_comptparm), "::", stringify!(sgnd))
    );
}
pub type opj_image_cmptparm_t = opj_image_comptparm;
#[doc = " Index structure : Information concerning a packet inside tile"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_packet_info {
    #[doc = " packet start position (including SOP marker if it exists)"]
    pub start_pos: OPJ_OFF_T,
    #[doc = " end of packet header position (including EPH marker if it exists)"]
    pub end_ph_pos: OPJ_OFF_T,
    #[doc = " packet end position"]
    pub end_pos: OPJ_OFF_T,
    #[doc = " packet distorsion"]
    pub disto: f64,
}
#[test]
fn bindgen_test_layout_opj_packet_info() {
    assert_eq!(
        ::std::mem::size_of::<opj_packet_info>(),
        32usize,
        concat!("Size of: ", stringify!(opj_packet_info))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_packet_info>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_packet_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_packet_info>())).start_pos as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(opj_packet_info), "::", stringify!(start_pos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_packet_info>())).end_ph_pos as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(opj_packet_info), "::", stringify!(end_ph_pos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_packet_info>())).end_pos as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(opj_packet_info), "::", stringify!(end_pos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_packet_info>())).disto as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(opj_packet_info), "::", stringify!(disto))
    );
}
pub type opj_packet_info_t = opj_packet_info;
#[doc = " Marker structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_marker_info {
    #[doc = " marker type"]
    pub type_: ::std::os::raw::c_ushort,
    #[doc = " position in codestream"]
    pub pos: OPJ_OFF_T,
    #[doc = " length, marker val included"]
    pub len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_opj_marker_info() {
    assert_eq!(
        ::std::mem::size_of::<opj_marker_info>(),
        24usize,
        concat!("Size of: ", stringify!(opj_marker_info))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_marker_info>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_marker_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_marker_info>())).type_ as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(opj_marker_info), "::", stringify!(type_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_marker_info>())).pos as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(opj_marker_info), "::", stringify!(pos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_marker_info>())).len as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(opj_marker_info), "::", stringify!(len))
    );
}
pub type opj_marker_info_t = opj_marker_info;
#[doc = " Index structure : Information concerning tile-parts"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_tp_info {
    #[doc = " start position of tile part"]
    pub tp_start_pos: ::std::os::raw::c_int,
    #[doc = " end position of tile part header"]
    pub tp_end_header: ::std::os::raw::c_int,
    #[doc = " end position of tile part"]
    pub tp_end_pos: ::std::os::raw::c_int,
    #[doc = " start packet of tile part"]
    pub tp_start_pack: ::std::os::raw::c_int,
    #[doc = " number of packets of tile part"]
    pub tp_numpacks: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_opj_tp_info() {
    assert_eq!(
        ::std::mem::size_of::<opj_tp_info>(),
        20usize,
        concat!("Size of: ", stringify!(opj_tp_info))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_tp_info>(),
        4usize,
        concat!("Alignment of ", stringify!(opj_tp_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tp_info>())).tp_start_pos as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(opj_tp_info), "::", stringify!(tp_start_pos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tp_info>())).tp_end_header as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(opj_tp_info), "::", stringify!(tp_end_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tp_info>())).tp_end_pos as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(opj_tp_info), "::", stringify!(tp_end_pos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tp_info>())).tp_start_pack as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(opj_tp_info), "::", stringify!(tp_start_pack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tp_info>())).tp_numpacks as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(opj_tp_info), "::", stringify!(tp_numpacks))
    );
}
pub type opj_tp_info_t = opj_tp_info;
#[doc = " Index structure : information regarding tiles"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct opj_tile_info {
    #[doc = " value of thresh for each layer by tile cfr. Marcela"]
    pub thresh: *mut f64,
    #[doc = " number of tile"]
    pub tileno: ::std::os::raw::c_int,
    #[doc = " start position"]
    pub start_pos: ::std::os::raw::c_int,
    #[doc = " end position of the header"]
    pub end_header: ::std::os::raw::c_int,
    #[doc = " end position"]
    pub end_pos: ::std::os::raw::c_int,
    #[doc = " precinct number for each resolution level (width)"]
    pub pw: [::std::os::raw::c_int; 33usize],
    #[doc = " precinct number for each resolution level (height)"]
    pub ph: [::std::os::raw::c_int; 33usize],
    #[doc = " precinct size (in power of 2), in X for each resolution level"]
    pub pdx: [::std::os::raw::c_int; 33usize],
    #[doc = " precinct size (in power of 2), in Y for each resolution level"]
    pub pdy: [::std::os::raw::c_int; 33usize],
    #[doc = " information concerning packets inside tile"]
    pub packet: *mut opj_packet_info_t,
    #[doc = " add fixed_quality"]
    pub numpix: ::std::os::raw::c_int,
    #[doc = " add fixed_quality"]
    pub distotile: f64,
    #[doc = " number of markers"]
    pub marknum: ::std::os::raw::c_int,
    #[doc = " list of markers"]
    pub marker: *mut opj_marker_info_t,
    #[doc = " actual size of markers array"]
    pub maxmarknum: ::std::os::raw::c_int,
    #[doc = " number of tile parts"]
    pub num_tps: ::std::os::raw::c_int,
    #[doc = " information concerning tile parts"]
    pub tp: *mut opj_tp_info_t,
}
#[test]
fn bindgen_test_layout_opj_tile_info() {
    assert_eq!(
        ::std::mem::size_of::<opj_tile_info>(),
        608usize,
        concat!("Size of: ", stringify!(opj_tile_info))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_tile_info>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_tile_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).thresh as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(opj_tile_info), "::", stringify!(thresh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).tileno as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(opj_tile_info), "::", stringify!(tileno))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).start_pos as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(opj_tile_info), "::", stringify!(start_pos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).end_header as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(opj_tile_info), "::", stringify!(end_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).end_pos as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(opj_tile_info), "::", stringify!(end_pos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).pw as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(opj_tile_info), "::", stringify!(pw))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).ph as *const _ as usize },
        156usize,
        concat!("Offset of field: ", stringify!(opj_tile_info), "::", stringify!(ph))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).pdx as *const _ as usize },
        288usize,
        concat!("Offset of field: ", stringify!(opj_tile_info), "::", stringify!(pdx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).pdy as *const _ as usize },
        420usize,
        concat!("Offset of field: ", stringify!(opj_tile_info), "::", stringify!(pdy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).packet as *const _ as usize },
        552usize,
        concat!("Offset of field: ", stringify!(opj_tile_info), "::", stringify!(packet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).numpix as *const _ as usize },
        560usize,
        concat!("Offset of field: ", stringify!(opj_tile_info), "::", stringify!(numpix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).distotile as *const _ as usize },
        568usize,
        concat!("Offset of field: ", stringify!(opj_tile_info), "::", stringify!(distotile))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).marknum as *const _ as usize },
        576usize,
        concat!("Offset of field: ", stringify!(opj_tile_info), "::", stringify!(marknum))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).marker as *const _ as usize },
        584usize,
        concat!("Offset of field: ", stringify!(opj_tile_info), "::", stringify!(marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).maxmarknum as *const _ as usize },
        592usize,
        concat!("Offset of field: ", stringify!(opj_tile_info), "::", stringify!(maxmarknum))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).num_tps as *const _ as usize },
        596usize,
        concat!("Offset of field: ", stringify!(opj_tile_info), "::", stringify!(num_tps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).tp as *const _ as usize },
        600usize,
        concat!("Offset of field: ", stringify!(opj_tile_info), "::", stringify!(tp))
    );
}
impl ::std::fmt::Debug for opj_tile_info {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "opj_tile_info {{ thresh: {:?}, tileno: {:?}, start_pos: {:?}, end_header: {:?}, end_pos: {:?}, pw: [{}], ph: [{}], pdx: [{}], pdy: [{}], packet: {:?}, numpix: {:?}, distotile: {:?}, marknum: {:?}, marker: {:?}, maxmarknum: {:?}, num_tps: {:?}, tp: {:?} }}" , self . thresh , self . tileno , self . start_pos , self . end_header , self . end_pos , self . pw . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . ph . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . pdx . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . pdy . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . packet , self . numpix , self . distotile , self . marknum , self . marker , self . maxmarknum , self . num_tps , self . tp )
    }
}
pub type opj_tile_info_t = opj_tile_info;
#[doc = " Index structure of the codestream"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_codestream_info {
    #[doc = " maximum distortion reduction on the whole image (add for Marcela)"]
    pub D_max: f64,
    #[doc = " packet number"]
    pub packno: ::std::os::raw::c_int,
    #[doc = " writing the packet in the index with t2_encode_packets"]
    pub index_write: ::std::os::raw::c_int,
    #[doc = " image width"]
    pub image_w: ::std::os::raw::c_int,
    #[doc = " image height"]
    pub image_h: ::std::os::raw::c_int,
    #[doc = " progression order"]
    pub prog: OPJ_PROG_ORDER,
    #[doc = " tile size in x"]
    pub tile_x: ::std::os::raw::c_int,
    #[doc = " tile size in y"]
    pub tile_y: ::std::os::raw::c_int,
    pub tile_Ox: ::std::os::raw::c_int,
    pub tile_Oy: ::std::os::raw::c_int,
    #[doc = " number of tiles in X"]
    pub tw: ::std::os::raw::c_int,
    #[doc = " number of tiles in Y"]
    pub th: ::std::os::raw::c_int,
    #[doc = " component numbers"]
    pub numcomps: ::std::os::raw::c_int,
    #[doc = " number of layer"]
    pub numlayers: ::std::os::raw::c_int,
    #[doc = " number of decomposition for each component"]
    pub numdecompos: *mut ::std::os::raw::c_int,
    #[doc = " number of markers"]
    pub marknum: ::std::os::raw::c_int,
    #[doc = " list of markers"]
    pub marker: *mut opj_marker_info_t,
    #[doc = " actual size of markers array"]
    pub maxmarknum: ::std::os::raw::c_int,
    #[doc = " main header position"]
    pub main_head_start: ::std::os::raw::c_int,
    #[doc = " main header position"]
    pub main_head_end: ::std::os::raw::c_int,
    #[doc = " codestream's size"]
    pub codestream_size: ::std::os::raw::c_int,
    #[doc = " information regarding tiles inside image"]
    pub tile: *mut opj_tile_info_t,
}
#[test]
fn bindgen_test_layout_opj_codestream_info() {
    assert_eq!(
        ::std::mem::size_of::<opj_codestream_info>(),
        112usize,
        concat!("Size of: ", stringify!(opj_codestream_info))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_codestream_info>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_codestream_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).D_max as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info), "::", stringify!(D_max))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).packno as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info), "::", stringify!(packno))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).index_write as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(index_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).image_w as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info), "::", stringify!(image_w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).image_h as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info), "::", stringify!(image_h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).prog as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info), "::", stringify!(prog))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).tile_x as *const _ as usize },
        28usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info), "::", stringify!(tile_x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).tile_y as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info), "::", stringify!(tile_y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).tile_Ox as *const _ as usize },
        36usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info), "::", stringify!(tile_Ox))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).tile_Oy as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info), "::", stringify!(tile_Oy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).tw as *const _ as usize },
        44usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info), "::", stringify!(tw))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).th as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info), "::", stringify!(th))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).numcomps as *const _ as usize },
        52usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info), "::", stringify!(numcomps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).numlayers as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info), "::", stringify!(numlayers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).numdecompos as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(numdecompos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).marknum as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info), "::", stringify!(marknum))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).marker as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info), "::", stringify!(marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).maxmarknum as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info), "::", stringify!(maxmarknum))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_codestream_info>())).main_head_start as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(main_head_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_codestream_info>())).main_head_end as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(main_head_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_codestream_info>())).codestream_size as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(codestream_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).tile as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info), "::", stringify!(tile))
    );
}
pub type opj_codestream_info_t = opj_codestream_info;
#[doc = " Tile-component coding parameters information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct opj_tccp_info {
    #[doc = " component index"]
    pub compno: OPJ_UINT32,
    #[doc = " coding style"]
    pub csty: OPJ_UINT32,
    #[doc = " number of resolutions"]
    pub numresolutions: OPJ_UINT32,
    #[doc = " log2 of code-blocks width"]
    pub cblkw: OPJ_UINT32,
    #[doc = " log2 of code-blocks height"]
    pub cblkh: OPJ_UINT32,
    #[doc = " code-block coding style"]
    pub cblksty: OPJ_UINT32,
    #[doc = " discrete wavelet transform identifier: 0 = 9-7 irreversible, 1 = 5-3 reversible"]
    pub qmfbid: OPJ_UINT32,
    #[doc = " quantisation style"]
    pub qntsty: OPJ_UINT32,
    #[doc = " stepsizes used for quantization"]
    pub stepsizes_mant: [OPJ_UINT32; 97usize],
    #[doc = " stepsizes used for quantization"]
    pub stepsizes_expn: [OPJ_UINT32; 97usize],
    #[doc = " number of guard bits"]
    pub numgbits: OPJ_UINT32,
    #[doc = " Region Of Interest shift"]
    pub roishift: OPJ_INT32,
    #[doc = " precinct width"]
    pub prcw: [OPJ_UINT32; 33usize],
    #[doc = " precinct height"]
    pub prch: [OPJ_UINT32; 33usize],
}
#[test]
fn bindgen_test_layout_opj_tccp_info() {
    assert_eq!(
        ::std::mem::size_of::<opj_tccp_info>(),
        1080usize,
        concat!("Size of: ", stringify!(opj_tccp_info))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_tccp_info>(),
        4usize,
        concat!("Alignment of ", stringify!(opj_tccp_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).compno as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(opj_tccp_info), "::", stringify!(compno))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).csty as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(opj_tccp_info), "::", stringify!(csty))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).numresolutions as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(opj_tccp_info), "::", stringify!(numresolutions))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).cblkw as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(opj_tccp_info), "::", stringify!(cblkw))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).cblkh as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(opj_tccp_info), "::", stringify!(cblkh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).cblksty as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(opj_tccp_info), "::", stringify!(cblksty))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).qmfbid as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(opj_tccp_info), "::", stringify!(qmfbid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).qntsty as *const _ as usize },
        28usize,
        concat!("Offset of field: ", stringify!(opj_tccp_info), "::", stringify!(qntsty))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).stepsizes_mant as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(opj_tccp_info), "::", stringify!(stepsizes_mant))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).stepsizes_expn as *const _ as usize },
        420usize,
        concat!("Offset of field: ", stringify!(opj_tccp_info), "::", stringify!(stepsizes_expn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).numgbits as *const _ as usize },
        808usize,
        concat!("Offset of field: ", stringify!(opj_tccp_info), "::", stringify!(numgbits))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).roishift as *const _ as usize },
        812usize,
        concat!("Offset of field: ", stringify!(opj_tccp_info), "::", stringify!(roishift))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).prcw as *const _ as usize },
        816usize,
        concat!("Offset of field: ", stringify!(opj_tccp_info), "::", stringify!(prcw))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).prch as *const _ as usize },
        948usize,
        concat!("Offset of field: ", stringify!(opj_tccp_info), "::", stringify!(prch))
    );
}
impl ::std::fmt::Debug for opj_tccp_info {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "opj_tccp_info {{ compno: {:?}, csty: {:?}, numresolutions: {:?}, cblkw: {:?}, cblkh: {:?}, cblksty: {:?}, qmfbid: {:?}, qntsty: {:?}, stepsizes_mant: [{}], stepsizes_expn: [{}], numgbits: {:?}, roishift: {:?}, prcw: [{}], prch: [{}] }}" , self . compno , self . csty , self . numresolutions , self . cblkw , self . cblkh , self . cblksty , self . qmfbid , self . qntsty , self . stepsizes_mant . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . stepsizes_expn . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . numgbits , self . roishift , self . prcw . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . prch . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) )
    }
}
pub type opj_tccp_info_t = opj_tccp_info;
#[doc = " Tile coding parameters information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_tile_v2_info {
    #[doc = " number (index) of tile"]
    pub tileno: ::std::os::raw::c_int,
    #[doc = " coding style"]
    pub csty: OPJ_UINT32,
    #[doc = " progression order"]
    pub prg: OPJ_PROG_ORDER,
    #[doc = " number of layers"]
    pub numlayers: OPJ_UINT32,
    #[doc = " multi-component transform identifier"]
    pub mct: OPJ_UINT32,
    #[doc = " information concerning tile component parameters"]
    pub tccp_info: *mut opj_tccp_info_t,
}
#[test]
fn bindgen_test_layout_opj_tile_v2_info() {
    assert_eq!(
        ::std::mem::size_of::<opj_tile_v2_info>(),
        32usize,
        concat!("Size of: ", stringify!(opj_tile_v2_info))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_tile_v2_info>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_tile_v2_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_v2_info>())).tileno as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(opj_tile_v2_info), "::", stringify!(tileno))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_v2_info>())).csty as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(opj_tile_v2_info), "::", stringify!(csty))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_v2_info>())).prg as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(opj_tile_v2_info), "::", stringify!(prg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_v2_info>())).numlayers as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(opj_tile_v2_info), "::", stringify!(numlayers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_v2_info>())).mct as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(opj_tile_v2_info), "::", stringify!(mct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_v2_info>())).tccp_info as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(opj_tile_v2_info), "::", stringify!(tccp_info))
    );
}
pub type opj_tile_info_v2_t = opj_tile_v2_info;
#[doc = " Information structure about the codestream (FIXME should be expand and enhance)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_codestream_info_v2 {
    #[doc = " tile origin in x = XTOsiz"]
    pub tx0: OPJ_UINT32,
    #[doc = " tile origin in y = YTOsiz"]
    pub ty0: OPJ_UINT32,
    #[doc = " tile size in x = XTsiz"]
    pub tdx: OPJ_UINT32,
    #[doc = " tile size in y = YTsiz"]
    pub tdy: OPJ_UINT32,
    #[doc = " number of tiles in X"]
    pub tw: OPJ_UINT32,
    #[doc = " number of tiles in Y"]
    pub th: OPJ_UINT32,
    #[doc = " number of components"]
    pub nbcomps: OPJ_UINT32,
    #[doc = " Default information regarding tiles inside image"]
    pub m_default_tile_info: opj_tile_info_v2_t,
    #[doc = " information regarding tiles inside image"]
    pub tile_info: *mut opj_tile_info_v2_t,
}
#[test]
fn bindgen_test_layout_opj_codestream_info_v2() {
    assert_eq!(
        ::std::mem::size_of::<opj_codestream_info_v2>(),
        72usize,
        concat!("Size of: ", stringify!(opj_codestream_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_codestream_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_codestream_info_v2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info_v2>())).tx0 as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info_v2), "::", stringify!(tx0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info_v2>())).ty0 as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info_v2), "::", stringify!(ty0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info_v2>())).tdx as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info_v2), "::", stringify!(tdx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info_v2>())).tdy as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info_v2), "::", stringify!(tdy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info_v2>())).tw as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info_v2), "::", stringify!(tw))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info_v2>())).th as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info_v2), "::", stringify!(th))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info_v2>())).nbcomps as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(opj_codestream_info_v2), "::", stringify!(nbcomps))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_codestream_info_v2>())).m_default_tile_info as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info_v2),
            "::",
            stringify!(m_default_tile_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_codestream_info_v2>())).tile_info as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info_v2),
            "::",
            stringify!(tile_info)
        )
    );
}
pub type opj_codestream_info_v2_t = opj_codestream_info_v2;
#[doc = " Index structure about a tile part"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_tp_index {
    #[doc = " start position"]
    pub start_pos: OPJ_OFF_T,
    #[doc = " end position of the header"]
    pub end_header: OPJ_OFF_T,
    #[doc = " end position"]
    pub end_pos: OPJ_OFF_T,
}
#[test]
fn bindgen_test_layout_opj_tp_index() {
    assert_eq!(
        ::std::mem::size_of::<opj_tp_index>(),
        24usize,
        concat!("Size of: ", stringify!(opj_tp_index))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_tp_index>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_tp_index))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tp_index>())).start_pos as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(opj_tp_index), "::", stringify!(start_pos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tp_index>())).end_header as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(opj_tp_index), "::", stringify!(end_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tp_index>())).end_pos as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(opj_tp_index), "::", stringify!(end_pos))
    );
}
pub type opj_tp_index_t = opj_tp_index;
#[doc = " Index structure about a tile"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_tile_index {
    #[doc = " tile index"]
    pub tileno: OPJ_UINT32,
    #[doc = " number of tile parts"]
    pub nb_tps: OPJ_UINT32,
    #[doc = " current nb of tile part (allocated)"]
    pub current_nb_tps: OPJ_UINT32,
    #[doc = " current tile-part index"]
    pub current_tpsno: OPJ_UINT32,
    #[doc = " information concerning tile parts"]
    pub tp_index: *mut opj_tp_index_t,
    #[doc = " number of markers"]
    pub marknum: OPJ_UINT32,
    #[doc = " list of markers"]
    pub marker: *mut opj_marker_info_t,
    #[doc = " actual size of markers array"]
    pub maxmarknum: OPJ_UINT32,
    #[doc = " packet number"]
    pub nb_packet: OPJ_UINT32,
    #[doc = " information concerning packets inside tile"]
    pub packet_index: *mut opj_packet_info_t,
}
#[test]
fn bindgen_test_layout_opj_tile_index() {
    assert_eq!(
        ::std::mem::size_of::<opj_tile_index>(),
        56usize,
        concat!("Size of: ", stringify!(opj_tile_index))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_tile_index>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_tile_index))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_index>())).tileno as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(opj_tile_index), "::", stringify!(tileno))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_index>())).nb_tps as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(opj_tile_index), "::", stringify!(nb_tps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_index>())).current_nb_tps as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(opj_tile_index), "::", stringify!(current_nb_tps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_index>())).current_tpsno as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(opj_tile_index), "::", stringify!(current_tpsno))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_index>())).tp_index as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(opj_tile_index), "::", stringify!(tp_index))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_index>())).marknum as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(opj_tile_index), "::", stringify!(marknum))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_index>())).marker as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(opj_tile_index), "::", stringify!(marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_index>())).maxmarknum as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(opj_tile_index), "::", stringify!(maxmarknum))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_index>())).nb_packet as *const _ as usize },
        44usize,
        concat!("Offset of field: ", stringify!(opj_tile_index), "::", stringify!(nb_packet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_index>())).packet_index as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(opj_tile_index), "::", stringify!(packet_index))
    );
}
pub type opj_tile_index_t = opj_tile_index;
#[doc = " Index structure of the codestream (FIXME should be expand and enhance)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_codestream_index {
    #[doc = " main header start position (SOC position)"]
    pub main_head_start: OPJ_OFF_T,
    #[doc = " main header end position (first SOT position)"]
    pub main_head_end: OPJ_OFF_T,
    #[doc = " codestream's size"]
    pub codestream_size: OPJ_UINT64,
    #[doc = " number of markers"]
    pub marknum: OPJ_UINT32,
    #[doc = " list of markers"]
    pub marker: *mut opj_marker_info_t,
    #[doc = " actual size of markers array"]
    pub maxmarknum: OPJ_UINT32,
    pub nb_of_tiles: OPJ_UINT32,
    pub tile_index: *mut opj_tile_index_t,
}
#[test]
fn bindgen_test_layout_opj_codestream_index() {
    assert_eq!(
        ::std::mem::size_of::<opj_codestream_index>(),
        56usize,
        concat!("Size of: ", stringify!(opj_codestream_index))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_codestream_index>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_codestream_index))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_codestream_index>())).main_head_start as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_index),
            "::",
            stringify!(main_head_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_codestream_index>())).main_head_end as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_index),
            "::",
            stringify!(main_head_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_codestream_index>())).codestream_size as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_index),
            "::",
            stringify!(codestream_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_index>())).marknum as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(opj_codestream_index), "::", stringify!(marknum))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_index>())).marker as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(opj_codestream_index), "::", stringify!(marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_index>())).maxmarknum as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_index),
            "::",
            stringify!(maxmarknum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_codestream_index>())).nb_of_tiles as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_index),
            "::",
            stringify!(nb_of_tiles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_index>())).tile_index as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_index),
            "::",
            stringify!(tile_index)
        )
    );
}
pub type opj_codestream_index_t = opj_codestream_index;
#[doc = " Info structure of the JP2 file"]
#[doc = " EXPERIMENTAL FOR THE MOMENT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_jp2_metadata {
    pub not_used: OPJ_INT32,
}
#[test]
fn bindgen_test_layout_opj_jp2_metadata() {
    assert_eq!(
        ::std::mem::size_of::<opj_jp2_metadata>(),
        4usize,
        concat!("Size of: ", stringify!(opj_jp2_metadata))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_jp2_metadata>(),
        4usize,
        concat!("Alignment of ", stringify!(opj_jp2_metadata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_jp2_metadata>())).not_used as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(opj_jp2_metadata), "::", stringify!(not_used))
    );
}
pub type opj_jp2_metadata_t = opj_jp2_metadata;
#[doc = " Index structure of the JP2 file"]
#[doc = " EXPERIMENTAL FOR THE MOMENT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_jp2_index {
    pub not_used: OPJ_INT32,
}
#[test]
fn bindgen_test_layout_opj_jp2_index() {
    assert_eq!(
        ::std::mem::size_of::<opj_jp2_index>(),
        4usize,
        concat!("Size of: ", stringify!(opj_jp2_index))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_jp2_index>(),
        4usize,
        concat!("Alignment of ", stringify!(opj_jp2_index))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_jp2_index>())).not_used as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(opj_jp2_index), "::", stringify!(not_used))
    );
}
pub type opj_jp2_index_t = opj_jp2_index;
extern "C" {
    pub fn opj_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Create an image"]
    #[doc = ""]
    #[doc = " @param numcmpts      number of components"]
    #[doc = " @param cmptparms     components parameters"]
    #[doc = " @param clrspc        image color space"]
    #[doc = " @return returns      a new image structure if successful, returns NULL otherwise"]
    pub fn opj_image_create(
        numcmpts: OPJ_UINT32,
        cmptparms: *mut opj_image_cmptparm_t,
        clrspc: OPJ_COLOR_SPACE,
    ) -> *mut opj_image_t;
}
extern "C" {
    #[doc = " Deallocate any resources associated with an image"]
    #[doc = ""]
    #[doc = " @param image         image to be destroyed"]
    pub fn opj_image_destroy(image: *mut opj_image_t);
}
extern "C" {
    #[doc = " Creates an image without allocating memory for the image (used in the new version of the library)."]
    #[doc = ""]
    #[doc = " @param   numcmpts    the number of components"]
    #[doc = " @param   cmptparms   the components parameters"]
    #[doc = " @param   clrspc      the image color space"]
    #[doc = ""]
    #[doc = " @return  a new image structure if successful, NULL otherwise."]
    pub fn opj_image_tile_create(
        numcmpts: OPJ_UINT32,
        cmptparms: *mut opj_image_cmptparm_t,
        clrspc: OPJ_COLOR_SPACE,
    ) -> *mut opj_image_t;
}
extern "C" {
    #[doc = " Allocator for opj_image_t->comps[].data"]
    #[doc = " To be paired with opj_image_data_free."]
    #[doc = ""]
    #[doc = " @param   size    number of bytes to allocate"]
    #[doc = ""]
    #[doc = " @return  a new pointer if successful, NULL otherwise."]
    #[doc = " @since 2.2.0"]
    pub fn opj_image_data_alloc(size: OPJ_SIZE_T) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Destructor for opj_image_t->comps[].data"]
    #[doc = " To be paired with opj_image_data_alloc."]
    #[doc = ""]
    #[doc = " @param   ptr    Pointer to free"]
    #[doc = ""]
    #[doc = " @since 2.2.0"]
    pub fn opj_image_data_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Creates an abstract stream. This function does nothing except allocating memory and initializing the abstract stream."]
    #[doc = ""]
    #[doc = " @param   p_is_input      if set to true then the stream will be an input stream, an output stream else."]
    #[doc = ""]
    #[doc = " @return  a stream object."]
    pub fn opj_stream_default_create(p_is_input: OPJ_BOOL) -> *mut opj_stream_t;
}
extern "C" {
    #[doc = " Creates an abstract stream. This function does nothing except allocating memory and initializing the abstract stream."]
    #[doc = ""]
    #[doc = " @param   p_buffer_size  FIXME DOC"]
    #[doc = " @param   p_is_input      if set to true then the stream will be an input stream, an output stream else."]
    #[doc = ""]
    #[doc = " @return  a stream object."]
    pub fn opj_stream_create(p_buffer_size: OPJ_SIZE_T, p_is_input: OPJ_BOOL) -> *mut opj_stream_t;
}
extern "C" {
    #[doc = " Destroys a stream created by opj_create_stream. This function does NOT close the abstract stream. If needed the user must"]
    #[doc = " close its own implementation of the stream."]
    #[doc = ""]
    #[doc = " @param   p_stream    the stream to destroy."]
    pub fn opj_stream_destroy(p_stream: *mut opj_stream_t);
}
extern "C" {
    #[doc = " Sets the given function to be used as a read function."]
    #[doc = " @param       p_stream    the stream to modify"]
    #[doc = " @param       p_function  the function to use a read function."]
    pub fn opj_stream_set_read_function(
        p_stream: *mut opj_stream_t,
        p_function: opj_stream_read_fn,
    );
}
extern "C" {
    #[doc = " Sets the given function to be used as a write function."]
    #[doc = " @param       p_stream    the stream to modify"]
    #[doc = " @param       p_function  the function to use a write function."]
    pub fn opj_stream_set_write_function(
        p_stream: *mut opj_stream_t,
        p_function: opj_stream_write_fn,
    );
}
extern "C" {
    #[doc = " Sets the given function to be used as a skip function."]
    #[doc = " @param       p_stream    the stream to modify"]
    #[doc = " @param       p_function  the function to use a skip function."]
    pub fn opj_stream_set_skip_function(
        p_stream: *mut opj_stream_t,
        p_function: opj_stream_skip_fn,
    );
}
extern "C" {
    #[doc = " Sets the given function to be used as a seek function, the stream is then seekable,"]
    #[doc = " using SEEK_SET behavior."]
    #[doc = " @param       p_stream    the stream to modify"]
    #[doc = " @param       p_function  the function to use a skip function."]
    pub fn opj_stream_set_seek_function(
        p_stream: *mut opj_stream_t,
        p_function: opj_stream_seek_fn,
    );
}
extern "C" {
    #[doc = " Sets the given data to be used as a user data for the stream."]
    #[doc = " @param       p_stream    the stream to modify"]
    #[doc = " @param       p_data      the data to set."]
    #[doc = " @param       p_function  the function to free p_data when opj_stream_destroy() is called."]
    pub fn opj_stream_set_user_data(
        p_stream: *mut opj_stream_t,
        p_data: *mut ::std::os::raw::c_void,
        p_function: opj_stream_free_user_data_fn,
    );
}
extern "C" {
    #[doc = " Sets the length of the user data for the stream."]
    #[doc = ""]
    #[doc = " @param p_stream    the stream to modify"]
    #[doc = " @param data_length length of the user_data."]
    pub fn opj_stream_set_user_data_length(p_stream: *mut opj_stream_t, data_length: OPJ_UINT64);
}
extern "C" {
    #[doc = " Create a stream from a file identified with its filename with default parameters (helper function)"]
    #[doc = " @param fname             the filename of the file to stream"]
    #[doc = " @param p_is_read_stream  whether the stream is a read stream (true) or not (false)"]
    pub fn opj_stream_create_default_file_stream(
        fname: *const ::std::os::raw::c_char,
        p_is_read_stream: OPJ_BOOL,
    ) -> *mut opj_stream_t;
}
extern "C" {
    #[doc = " Create a stream from a file identified with its filename with a specific buffer size"]
    #[doc = " @param fname             the filename of the file to stream"]
    #[doc = " @param p_buffer_size     size of the chunk used to stream"]
    #[doc = " @param p_is_read_stream  whether the stream is a read stream (true) or not (false)"]
    pub fn opj_stream_create_file_stream(
        fname: *const ::std::os::raw::c_char,
        p_buffer_size: OPJ_SIZE_T,
        p_is_read_stream: OPJ_BOOL,
    ) -> *mut opj_stream_t;
}
extern "C" {
    #[doc = " Set the info handler use by openjpeg."]
    #[doc = " @param p_codec       the codec previously initialise"]
    #[doc = " @param p_callback    the callback function which will be used"]
    #[doc = " @param p_user_data   client object where will be returned the message"]
    pub fn opj_set_info_handler(
        p_codec: *mut opj_codec_t,
        p_callback: opj_msg_callback,
        p_user_data: *mut ::std::os::raw::c_void,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Set the warning handler use by openjpeg."]
    #[doc = " @param p_codec       the codec previously initialise"]
    #[doc = " @param p_callback    the callback function which will be used"]
    #[doc = " @param p_user_data   client object where will be returned the message"]
    pub fn opj_set_warning_handler(
        p_codec: *mut opj_codec_t,
        p_callback: opj_msg_callback,
        p_user_data: *mut ::std::os::raw::c_void,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Set the error handler use by openjpeg."]
    #[doc = " @param p_codec       the codec previously initialise"]
    #[doc = " @param p_callback    the callback function which will be used"]
    #[doc = " @param p_user_data   client object where will be returned the message"]
    pub fn opj_set_error_handler(
        p_codec: *mut opj_codec_t,
        p_callback: opj_msg_callback,
        p_user_data: *mut ::std::os::raw::c_void,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Creates a J2K/JP2 decompression structure"]
    #[doc = " @param format        Decoder to select"]
    #[doc = ""]
    #[doc = " @return Returns a handle to a decompressor if successful, returns NULL otherwise"]
    pub fn opj_create_decompress(format: OPJ_CODEC_FORMAT) -> *mut opj_codec_t;
}
extern "C" {
    #[doc = " Destroy a decompressor handle"]
    #[doc = ""]
    #[doc = " @param   p_codec         decompressor handle to destroy"]
    pub fn opj_destroy_codec(p_codec: *mut opj_codec_t);
}
extern "C" {
    #[doc = " Read after the codestream if necessary"]
    #[doc = " @param   p_codec         the JPEG2000 codec to read."]
    #[doc = " @param   p_stream        the JPEG2000 stream."]
    pub fn opj_end_decompress(p_codec: *mut opj_codec_t, p_stream: *mut opj_stream_t) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Set decoding parameters to default values"]
    #[doc = " @param parameters Decompression parameters"]
    pub fn opj_set_default_decoder_parameters(parameters: *mut opj_dparameters_t);
}
extern "C" {
    #[doc = " Setup the decoder with decompression parameters provided by the user and with the message handler"]
    #[doc = " provided by the user."]
    #[doc = ""]
    #[doc = " @param p_codec       decompressor handler"]
    #[doc = " @param parameters    decompression parameters"]
    #[doc = ""]
    #[doc = " @return true         if the decoder is correctly set"]
    pub fn opj_setup_decoder(
        p_codec: *mut opj_codec_t,
        parameters: *mut opj_dparameters_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Allocates worker threads for the compressor/decompressor."]
    #[doc = ""]
    #[doc = " By default, only the main thread is used. If this function is not used,"]
    #[doc = " but the OPJ_NUM_THREADS environment variable is set, its value will be"]
    #[doc = " used to initialize the number of threads. The value can be either an integer"]
    #[doc = " number, or \"ALL_CPUS\". If OPJ_NUM_THREADS is set and this function is called,"]
    #[doc = " this function will override the behaviour of the environment variable."]
    #[doc = ""]
    #[doc = " Currently this function must be called after opj_setup_decoder() and"]
    #[doc = " before opj_read_header()."]
    #[doc = ""]
    #[doc = " Note: currently only has effect on the decompressor."]
    #[doc = ""]
    #[doc = " @param p_codec       decompressor handler"]
    #[doc = " @param num_threads   number of threads."]
    #[doc = ""]
    #[doc = " @return OPJ_TRUE     if the decoder is correctly set"]
    pub fn opj_codec_set_threads(
        p_codec: *mut opj_codec_t,
        num_threads: ::std::os::raw::c_int,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Decodes an image header."]
    #[doc = ""]
    #[doc = " @param   p_stream        the jpeg2000 stream."]
    #[doc = " @param   p_codec         the jpeg2000 codec to read."]
    #[doc = " @param   p_image         the image structure initialized with the characteristics of encoded image."]
    #[doc = ""]
    #[doc = " @return true             if the main header of the codestream and the JP2 header is correctly read."]
    pub fn opj_read_header(
        p_stream: *mut opj_stream_t,
        p_codec: *mut opj_codec_t,
        p_image: *mut *mut opj_image_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Restrict the number of components to decode."]
    #[doc = ""]
    #[doc = " This function should be called after opj_read_header()."]
    #[doc = ""]
    #[doc = " This function enables to restrict the set of decoded components to the"]
    #[doc = " specified indices."]
    #[doc = " Note that the current implementation (apply_color_transforms == OPJ_FALSE)"]
    #[doc = " is such that neither the multi-component transform at codestream level,"]
    #[doc = " nor JP2 channel transformations will be applied."]
    #[doc = " Consequently the indices are relative to the codestream."]
    #[doc = ""]
    #[doc = " Note: opj_decode_tile_data() should not be used together with opj_set_decoded_components()."]
    #[doc = ""]
    #[doc = " @param   p_codec         the jpeg2000 codec to read."]
    #[doc = " @param   numcomps        Size of the comps_indices array."]
    #[doc = " @param   comps_indices   Array of numcomps values representing the indices"]
    #[doc = "                          of the components to decode (relative to the"]
    #[doc = "                          codestream, starting at 0)"]
    #[doc = " @param   apply_color_transforms Whether multi-component transform at codestream level"]
    #[doc = "                                 or JP2 channel transformations should be applied."]
    #[doc = "                                 Currently this parameter should be set to OPJ_FALSE."]
    #[doc = "                                 Setting it to OPJ_TRUE will result in an error."]
    #[doc = ""]
    #[doc = " @return OPJ_TRUE         in case of success."]
    pub fn opj_set_decoded_components(
        p_codec: *mut opj_codec_t,
        numcomps: OPJ_UINT32,
        comps_indices: *const OPJ_UINT32,
        apply_color_transforms: OPJ_BOOL,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Sets the given area to be decoded. This function should be called right after opj_read_header and before any tile header reading."]
    #[doc = ""]
    #[doc = " The coordinates passed to this function should be expressed in the reference grid,"]
    #[doc = " that is to say at the highest resolution level, even if requesting the image at lower"]
    #[doc = " resolution levels."]
    #[doc = ""]
    #[doc = " Generally opj_set_decode_area() should be followed by opj_decode(), and the"]
    #[doc = " codec cannot be re-used."]
    #[doc = " In the particular case of an image made of a single tile, several sequences of"]
    #[doc = " calls to opoj_set_decode_area() and opj_decode() are allowed, and will bring"]
    #[doc = " performance improvements when reading an image by chunks."]
    #[doc = ""]
    #[doc = " @param   p_codec         the jpeg2000 codec."]
    #[doc = " @param   p_image         the decoded image previously set by opj_read_header"]
    #[doc = " @param   p_start_x       the left position of the rectangle to decode (in image coordinates)."]
    #[doc = " @param   p_end_x         the right position of the rectangle to decode (in image coordinates)."]
    #[doc = " @param   p_start_y       the up position of the rectangle to decode (in image coordinates)."]
    #[doc = " @param   p_end_y         the bottom position of the rectangle to decode (in image coordinates)."]
    #[doc = ""]
    #[doc = " @return  true            if the area could be set."]
    pub fn opj_set_decode_area(
        p_codec: *mut opj_codec_t,
        p_image: *mut opj_image_t,
        p_start_x: OPJ_INT32,
        p_start_y: OPJ_INT32,
        p_end_x: OPJ_INT32,
        p_end_y: OPJ_INT32,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Decode an image from a JPEG-2000 codestream"]
    #[doc = ""]
    #[doc = " @param p_decompressor    decompressor handle"]
    #[doc = " @param p_stream          Input buffer stream"]
    #[doc = " @param p_image           the decoded image"]
    #[doc = " @return                  true if success, otherwise false"]
    pub fn opj_decode(
        p_decompressor: *mut opj_codec_t,
        p_stream: *mut opj_stream_t,
        p_image: *mut opj_image_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Get the decoded tile from the codec"]
    #[doc = ""]
    #[doc = " @param   p_codec         the jpeg2000 codec."]
    #[doc = " @param   p_stream        input streamm"]
    #[doc = " @param   p_image         output image"]
    #[doc = " @param   tile_index      index of the tile which will be decode"]
    #[doc = ""]
    #[doc = " @return                  true if success, otherwise false"]
    pub fn opj_get_decoded_tile(
        p_codec: *mut opj_codec_t,
        p_stream: *mut opj_stream_t,
        p_image: *mut opj_image_t,
        tile_index: OPJ_UINT32,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Set the resolution factor of the decoded image"]
    #[doc = " @param   p_codec         the jpeg2000 codec."]
    #[doc = " @param   res_factor      resolution factor to set"]
    #[doc = ""]
    #[doc = " @return                  true if success, otherwise false"]
    pub fn opj_set_decoded_resolution_factor(
        p_codec: *mut opj_codec_t,
        res_factor: OPJ_UINT32,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Writes a tile with the given data."]
    #[doc = ""]
    #[doc = " @param   p_codec             the jpeg2000 codec."]
    #[doc = " @param   p_tile_index        the index of the tile to write. At the moment, the tiles must be written from 0 to n-1 in sequence."]
    #[doc = " @param   p_data              pointer to the data to write. Data is arranged in sequence, data_comp0, then data_comp1, then ... NO INTERLEAVING should be set."]
    #[doc = " @param   p_data_size         this value os used to make sure the data being written is correct. The size must be equal to the sum for each component of"]
    #[doc = "                              tile_width * tile_height * component_size. component_size can be 1,2 or 4 bytes, depending on the precision of the given component."]
    #[doc = " @param   p_stream            the stream to write data to."]
    #[doc = ""]
    #[doc = " @return  true if the data could be written."]
    pub fn opj_write_tile(
        p_codec: *mut opj_codec_t,
        p_tile_index: OPJ_UINT32,
        p_data: *mut OPJ_BYTE,
        p_data_size: OPJ_UINT32,
        p_stream: *mut opj_stream_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Reads a tile header. This function is compulsory and allows one to know the size of the tile that will be decoded."]
    #[doc = " The user may need to refer to the image got by opj_read_header to understand the size being taken by the tile."]
    #[doc = ""]
    #[doc = " @param   p_codec         the jpeg2000 codec."]
    #[doc = " @param   p_tile_index    pointer to a value that will hold the index of the tile being decoded, in case of success."]
    #[doc = " @param   p_data_size     pointer to a value that will hold the maximum size of the decoded data, in case of success. In case"]
    #[doc = "                          of truncated codestreams, the actual number of bytes decoded may be lower. The computation of the size is the same"]
    #[doc = "                          as depicted in opj_write_tile."]
    #[doc = " @param   p_tile_x0       pointer to a value that will hold the x0 pos of the tile (in the image)."]
    #[doc = " @param   p_tile_y0       pointer to a value that will hold the y0 pos of the tile (in the image)."]
    #[doc = " @param   p_tile_x1       pointer to a value that will hold the x1 pos of the tile (in the image)."]
    #[doc = " @param   p_tile_y1       pointer to a value that will hold the y1 pos of the tile (in the image)."]
    #[doc = " @param   p_nb_comps      pointer to a value that will hold the number of components in the tile."]
    #[doc = " @param   p_should_go_on  pointer to a boolean that will hold the fact that the decoding should go on. In case the"]
    #[doc = "                          codestream is over at the time of the call, the value will be set to false. The user should then stop"]
    #[doc = "                          the decoding."]
    #[doc = " @param   p_stream        the stream to decode."]
    #[doc = " @return  true            if the tile header could be decoded. In case the decoding should end, the returned value is still true."]
    #[doc = "                          returning false may be the result of a shortage of memory or an internal error."]
    pub fn opj_read_tile_header(
        p_codec: *mut opj_codec_t,
        p_stream: *mut opj_stream_t,
        p_tile_index: *mut OPJ_UINT32,
        p_data_size: *mut OPJ_UINT32,
        p_tile_x0: *mut OPJ_INT32,
        p_tile_y0: *mut OPJ_INT32,
        p_tile_x1: *mut OPJ_INT32,
        p_tile_y1: *mut OPJ_INT32,
        p_nb_comps: *mut OPJ_UINT32,
        p_should_go_on: *mut OPJ_BOOL,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Reads a tile data. This function is compulsory and allows one to decode tile data. opj_read_tile_header should be called before."]
    #[doc = " The user may need to refer to the image got by opj_read_header to understand the size being taken by the tile."]
    #[doc = ""]
    #[doc = " Note: opj_decode_tile_data() should not be used together with opj_set_decoded_components()."]
    #[doc = ""]
    #[doc = " @param   p_codec         the jpeg2000 codec."]
    #[doc = " @param   p_tile_index    the index of the tile being decoded, this should be the value set by opj_read_tile_header."]
    #[doc = " @param   p_data          pointer to a memory block that will hold the decoded data."]
    #[doc = " @param   p_data_size     size of p_data. p_data_size should be bigger or equal to the value set by opj_read_tile_header."]
    #[doc = " @param   p_stream        the stream to decode."]
    #[doc = ""]
    #[doc = " @return  true            if the data could be decoded."]
    pub fn opj_decode_tile_data(
        p_codec: *mut opj_codec_t,
        p_tile_index: OPJ_UINT32,
        p_data: *mut OPJ_BYTE,
        p_data_size: OPJ_UINT32,
        p_stream: *mut opj_stream_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Creates a J2K/JP2 compression structure"]
    #[doc = " @param   format      Coder to select"]
    #[doc = " @return              Returns a handle to a compressor if successful, returns NULL otherwise"]
    pub fn opj_create_compress(format: OPJ_CODEC_FORMAT) -> *mut opj_codec_t;
}
extern "C" {
    #[doc = "Set encoding parameters to default values, that means :"]
    #[doc = "<ul>"]
    #[doc = "<li>Lossless"]
    #[doc = "<li>1 tile"]
    #[doc = "<li>Size of precinct : 2^15 x 2^15 (means 1 precinct)"]
    #[doc = "<li>Size of code-block : 64 x 64"]
    #[doc = "<li>Number of resolutions: 6"]
    #[doc = "<li>No SOP marker in the codestream"]
    #[doc = "<li>No EPH marker in the codestream"]
    #[doc = "<li>No sub-sampling in x or y direction"]
    #[doc = "<li>No mode switch activated"]
    #[doc = "<li>Progression order: LRCP"]
    #[doc = "<li>No index file"]
    #[doc = "<li>No ROI upshifted"]
    #[doc = "<li>No offset of the origin of the image"]
    #[doc = "<li>No offset of the origin of the tiles"]
    #[doc = "<li>Reversible DWT 5-3"]
    #[doc = "</ul>"]
    #[doc = "@param parameters Compression parameters"]
    pub fn opj_set_default_encoder_parameters(parameters: *mut opj_cparameters_t);
}
extern "C" {
    #[doc = " Setup the encoder parameters using the current image and using user parameters."]
    #[doc = " @param p_codec       Compressor handle"]
    #[doc = " @param parameters    Compression parameters"]
    #[doc = " @param image         Input filled image"]
    pub fn opj_setup_encoder(
        p_codec: *mut opj_codec_t,
        parameters: *mut opj_cparameters_t,
        image: *mut opj_image_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Start to compress the current image."]
    #[doc = " @param p_codec       Compressor handle"]
    #[doc = " @param p_image       Input filled image"]
    #[doc = " @param p_stream      Input stgream"]
    pub fn opj_start_compress(
        p_codec: *mut opj_codec_t,
        p_image: *mut opj_image_t,
        p_stream: *mut opj_stream_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " End to compress the current image."]
    #[doc = " @param p_codec       Compressor handle"]
    #[doc = " @param p_stream      Input stgream"]
    pub fn opj_end_compress(p_codec: *mut opj_codec_t, p_stream: *mut opj_stream_t) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Encode an image into a JPEG-2000 codestream"]
    #[doc = " @param p_codec       compressor handle"]
    #[doc = " @param p_stream      Output buffer stream"]
    #[doc = ""]
    #[doc = " @return              Returns true if successful, returns false otherwise"]
    pub fn opj_encode(p_codec: *mut opj_codec_t, p_stream: *mut opj_stream_t) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Destroy Codestream information after compression or decompression"]
    #[doc = "@param cstr_info Codestream information structure"]
    pub fn opj_destroy_cstr_info(cstr_info: *mut *mut opj_codestream_info_v2_t);
}
extern "C" {
    #[doc = " Dump the codec information into the output stream"]
    #[doc = ""]
    #[doc = " @param   p_codec         the jpeg2000 codec."]
    #[doc = " @param   info_flag       type of information dump."]
    #[doc = " @param   output_stream   output stream where dump the information gotten from the codec."]
    #[doc = ""]
    pub fn opj_dump_codec(
        p_codec: *mut opj_codec_t,
        info_flag: OPJ_INT32,
        output_stream: *mut FILE,
    );
}
extern "C" {
    #[doc = " Get the codestream information from the codec"]
    #[doc = ""]
    #[doc = " @param   p_codec         the jpeg2000 codec."]
    #[doc = ""]
    #[doc = " @return                  a pointer to a codestream information structure."]
    #[doc = ""]
    pub fn opj_get_cstr_info(p_codec: *mut opj_codec_t) -> *mut opj_codestream_info_v2_t;
}
extern "C" {
    #[doc = " Get the codestream index from the codec"]
    #[doc = ""]
    #[doc = " @param   p_codec         the jpeg2000 codec."]
    #[doc = ""]
    #[doc = " @return                  a pointer to a codestream index structure."]
    #[doc = ""]
    pub fn opj_get_cstr_index(p_codec: *mut opj_codec_t) -> *mut opj_codestream_index_t;
}
extern "C" {
    pub fn opj_destroy_cstr_index(p_cstr_index: *mut *mut opj_codestream_index_t);
}
extern "C" {
    #[doc = " Get the JP2 file information from the codec FIXME"]
    #[doc = ""]
    #[doc = " @param   p_codec         the jpeg2000 codec."]
    #[doc = ""]
    #[doc = " @return                  a pointer to a JP2 metadata structure."]
    #[doc = ""]
    pub fn opj_get_jp2_metadata(p_codec: *mut opj_codec_t) -> *mut opj_jp2_metadata_t;
}
extern "C" {
    #[doc = " Get the JP2 file index from the codec FIXME"]
    #[doc = ""]
    #[doc = " @param   p_codec         the jpeg2000 codec."]
    #[doc = ""]
    #[doc = " @return                  a pointer to a JP2 index structure."]
    #[doc = ""]
    pub fn opj_get_jp2_index(p_codec: *mut opj_codec_t) -> *mut opj_jp2_index_t;
}
extern "C" {
    #[doc = " Sets the MCT matrix to use."]
    #[doc = ""]
    #[doc = " @param   parameters      the parameters to change."]
    #[doc = " @param   pEncodingMatrix the encoding matrix."]
    #[doc = " @param   p_dc_shift      the dc shift coefficients to use."]
    #[doc = " @param   pNbComp         the number of components of the image."]
    #[doc = ""]
    #[doc = " @return  true if the parameters could be set."]
    pub fn opj_set_MCT(
        parameters: *mut opj_cparameters_t,
        pEncodingMatrix: *mut OPJ_FLOAT32,
        p_dc_shift: *mut OPJ_INT32,
        pNbComp: OPJ_UINT32,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Returns if the library is built with thread support."]
    #[doc = " OPJ_TRUE if mutex, condition, thread, thread pool are available."]
    pub fn opj_has_thread_support() -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Return the number of virtual CPUs"]
    pub fn opj_get_num_cpus() -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__va_list_tag), "::", stringify!(gp_offset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(__va_list_tag), "::", stringify!(fp_offset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(__va_list_tag), "::", stringify!(reg_save_area))
    );
}
